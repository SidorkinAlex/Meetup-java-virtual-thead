# Материалы для  митапа TechMeetup#2 Java | JVM от Холдинга Т1
## Виртуальные потоки JAVA

### Характеристики производительности
Несмотря на разницу в стоимости создания,

виртуальные потоки не быстрее, чем потоки платформы ; мы не можем выполнить больше вычислений с одним виртуальным потоком за одну секунду, чем с потоком платформы.

Мы также не можем планировать более активные виртуальные потоки, чем потоки платформы ; оба ограничены количеством доступных ядер ЦП.

Итак, в чем же выгода? Поскольку они настолько легкие, у нас может быть гораздо больше неактивных виртуальных потоков, чем при использовании потоков платформы .

### Виртуальные потоки в действии

В следующем примере создаются 100 000 виртуальных потоков, которые имитируют операцию ввода-вывода, переходя в режим ожидания на одну секунду. Он создает исполнитель виртуального потока для каждой задачи и отправляет задачи в виде лямбда-выражений.
```
try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
IntStream.range(0, 100_000).forEach(i -> {
executor.submit(() -> {
Thread.sleep(Duration.ofSeconds(1));
return i;
});
});
}  // close() called implicitly
```

При использовании виртуальных потоков запуск этой программы занимает около 1,6 секунды при холодном запуске и около 1,1 секунды после прогрева.

Если вместо этого мы попытаемся запустить эту программу с кешированным пулом потоков, в зависимости от объема доступной памяти она вполне может завершиться с ошибкой OutOfMemoryError до того, как будут отправлены все задачи.

И если мы запустим его с пулом потоков фиксированного размера с 1000 потоками, он не выйдет из строя, но для завершения потребуется 100 секунд.